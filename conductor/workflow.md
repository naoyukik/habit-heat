# プロジェクトワークフロー

## 指針

1. **計画が唯一の信頼できる情報源である:** すべての作業は `plan.md` で追跡されなければならない。
2. **技術スタックは意図的である:** 技術スタックへの変更は、実装*前*に `tech-stack.md` に文書化されなければならない。
3. **テスト駆動開発:** 機能を実装する前に単体テストを作成する。
4. **高いコードカバレッジ:** すべてのモジュールで 80% 以上のコードカバレッジを目指す。
5. **ユーザー体験第一:** すべての決定はユーザー体験を優先すべきである。
6. **非対話型 & CI認識:** 非対話型コマンドを優先する。ウォッチモードのツール（テスト、リンター）には `CI=true` を使用し、一度だけの実行を保証する。

## タスクワークフロー

すべてのタスクは厳格なライフサイクルに従う:

### 標準タスクワークフロー

1. **タスクの選択:** `plan.md` から次に利用可能なタスクを順に選択する。

2. **進行中としてマーク:** 作業を開始する前に、`plan.md` を編集し、タスクを `[ ]` から `[~]` に変更する。

3. **失敗するテストの作成 (レッドフェーズ):**
   - 機能またはバグ修正のための新しいテストファイルを作成する。
   - タスクの期待される動作と受け入れ基準を明確に定義する1つ以上の単体テストを作成する。
   - **重要:** テストを実行し、期待通りに失敗することを確認する。これがTDDの「レッド」フェーズである。テストが失敗するまで先に進んではならない。

4. **テストに合格するための実装 (グリーンフェーズ):**
   - 失敗しているテストを合格させるために必要な最小限のアプリケーションコードを書く。
   - 再度テストスイートを実行し、すべてのテストが合格することを確認する。これが「グリーン」フェーズである。

5. **リファクタリング (任意だが推奨):**
   - 合格したテストの安全性を確保した上で、実装コードとテストコードをリファクタリングし、外部の振る舞いを変えることなく、明確さの向上、重複の排除、パフォーマンスの強化を行う。
   - リファクタリング後もテストが合格し続けることを確認するために、テストを再実行する。

6. **カバレッジの検証:** プロジェクトで選択されたツールを使用してカバレッジレポートを実行する。例えば、Pythonプロジェクトでは以下のようになる:

   ```bash
   pytest --cov=app --cov-report=html
   ```

   目標: 新しいコードに対して 80% 以上のカバレッジ。具体的なツールやコマンドは言語やフレームワークによって異なる。

7. **逸脱の文書化:** 実装が技術スタックと異なる場合:
   - 実装を**停止**する
   - `tech-stack.md` を新しい設計で更新する
   - 変更を説明する日付付きのメモを追加する
   - 実装を再開する

8. **コード変更のコミット:**
   - タスクに関連するすべてのコード変更をステージングする。
   - 明確で簡潔なコミットメッセージを提案する。例: `feat(ui): Create basic HTML structure for calculator`
   - コミットを実行する。

9. **Git Notes でタスクサマリーを添付:**
   - **ステップ 9.1: コミットハッシュの取得:** *完了したばかりのコミット*のハッシュを取得する (`git log -1 --format="%H"`)。
   - **ステップ 9.2: ノート内容の下書き:** 完了したタスクの詳細なサマリーを作成する。これには、タスク名、変更の概要、作成/修正されたすべてのファイルのリスト、変更の核心的な「理由」を含めるべきである。
   - **ステップ 9.3: ノートの添付:** `git notes` コマンドを使用して、サマリーをコミットに添付する。
     ```bash
     # 前のステップからのノート内容は -m フラグで渡される。
     git notes add -m "<note content>" <commit_hash>
     ```

10. **タスクコミットSHAの取得と記録:**
    - **ステップ 10.1: 計画の更新:** `plan.md` を読み、完了したタスクの行を見つけ、ステータスを `[~]` から `[x]` に更新し、*完了したばかりのコミット*のコミットハッシュの最初の7文字を追記する。
    - **ステップ 10.2: 計画の書き込み:** 更新された内容を `plan.md` に書き戻す。

11. **計画更新のコミット:**
    - **アクション:** 変更された `plan.md` ファイルをステージングする。
    - **アクション:** 説明的なメッセージでこの変更をコミットする (例: `conductor(plan): Mark task 'Create user model' as complete`)。

### フェーズ完了検証およびチェックポイントプロトコル

**トリガー:** このプロトコルは、`plan.md` のフェーズを終了させるタスクが完了した直後に実行される。

1.  **プロトコル開始の宣言:** ユーザーにフェーズが完了し、検証およびチェックポイントプロトコルが開始されたことを通知する。

2.  **フェーズ変更に対するテストカバレッジの確保:**
    - **ステップ 2.1: フェーズの範囲決定:** このフェーズで変更されたファイルを特定するために、まず開始点を見つける必要があります。`plan.md` を読み、*前回の*フェーズのチェックポイントの Git コミット SHA を見つける。前回のチェックポイントが存在しない場合、範囲は最初のコミット以降のすべての変更となる。
    - **ステップ 2.2: 変更されたファイルのリストアップ:** `git diff --name-only <previous_checkpoint_sha> HEAD` を実行して、このフェーズで修正されたすべてのファイルの正確なリストを取得する。
    - **ステップ 2.3: テストの検証と作成:** リスト内の各ファイルについて:
      - **重要:** まず、拡張子を確認する。非コードファイル（例: `.json`, `.md`, `.yaml`）を除外する。
      - 残りの各コードファイルについて、対応するテストファイルが存在することを確認する。
      - テストファイルが不足している場合、**必ず**作成しなければならない。テストを書く前に、**まずリポジトリ内の他のテストファイルを分析し、正しい命名規則とテストスタイルを決定する。** 新しいテストは、このフェーズのタスク（`plan.md`）で記述された機能を検証するものでなければならない。

3.  **プロアクティブなデバッグ伴う自動テストの実行:**
    - 実行前に、テストを実行するために使用する正確なシェルコマンドを**必ず**宣言する。
    - **宣言例:** "フェーズを検証するために自動テストスイートを実行します。**コマンド:** `CI=true npm test`"
    - 宣言したコマンドを実行する。
    - テストが失敗した場合、**必ず**ユーザーに通知し、デバッグを開始する。修正案は**最大2回**まで提示できる。2回目の修正案の後もテストが失敗し続ける場合は、**停止**し、持続的な失敗を報告してユーザーにガイダンスを求める必要がある。

4.  **詳細で実行可能な手動検証計画の提案:**
    - **重要:** 計画を作成するために、まず `product.md`, `product-guidelines.md`, `plan.md` を分析し、完了したフェーズのユーザー向けゴールを決定する。
    - ユーザーに検証プロセスを案内するステップバイステップの計画を作成しなければならない。これには必要なコマンドと、具体的で期待される結果を含める。
    - ユーザーに提示する計画は、以下の形式に従わなければならない:

      **フロントエンドの変更の場合:**

      ```
      自動テストは合格しました。手動検証については、以下の手順に従ってください:

      **手動検証手順:**
      1.  **次のコマンドで開発サーバーを起動します:** `npm run dev`
      2.  **ブラウザで次を開きます:** `http://localhost:3000`
      3.  **次が表示されることを確認します:** 新しいユーザープロフィールページ（ユーザーの名前とメールアドレスが正しく表示されていること）。
      ```

      **バックエンドの変更の場合:**

      ```
      自動テストは合格しました。手動検証については、以下の手順に従ってください:

      **手動検証手順:**
      1.  **サーバーが実行されていることを確認します。**
      2.  **ターミナルで次のコマンドを実行します:** `curl -X POST http://localhost:8080/api/v1/users -d '{"name": "test"}'`
      3.  **次を受け取ることを確認します:** ステータス `201 Created` の JSON レスポンス。
      ```

5.  **明確なユーザーフィードバックの待機:**
    - 詳細な計画を提示した後、ユーザーに確認を求める: "**これは期待通りですか？ はい（yes）で確認するか、変更が必要な点についてフィードバックをください。**"
    - **一時停止**し、ユーザーの応答を待つ。明確な「はい」や確認なしに進めてはならない。

6.  **チェックポイントコミットの作成:**
    - すべての変更をステージングする。このステップで変更が発生しなかった場合は、空のコミットで進める。
    - 明確で簡潔なメッセージでコミットを実行する（例: `conductor(checkpoint): Checkpoint end of Phase X`）。

7.  **Git Notes を使用した監査可能な検証レポートの添付:**
    - **ステップ 8.1: ノート内容の下書き:** 自動テストコマンド、手動検証手順、およびユーザーの確認を含む詳細な検証レポートを作成する。
    - **ステップ 8.2: ノートの添付:** `git notes` コマンドと前のステップの完全なコミットハッシュを使用して、完全なレポートをチェックポイントコミットに添付する。

8.  **フェーズチェックポイントSHAの取得と記録:**
    - **ステップ 7.1: コミットハッシュの取得:** *作成したばかりのチェックポイントコミット*のハッシュを取得する (`git log -1 --format="%H"`)。
    - **ステップ 7.2: 計画の更新:** `plan.md` を読み、完了したフェーズの見出しを見つけ、`[checkpoint: <sha>]` の形式でコミットハッシュの最初の7文字を追記する。
    - **ステップ 7.3: 計画の書き込み:** 更新された内容を `plan.md` に書き戻す。

9.  **計画更新のコミット:**
    - **アクション:** 変更された `plan.md` ファイルをステージングする。
    - **アクション:** `conductor(plan): Mark phase '<PHASE NAME>' as complete` という形式に従った説明的なメッセージでこの変更をコミットする。

10. **完了の宣言:** ユーザーにフェーズが完了し、チェックポイントが作成され、詳細な検証レポートが git note として添付されたことを通知する。

### 品質ゲート

タスク完了をマークする前に、以下を検証する:

- [ ] すべてのテストが合格している
- [ ] コードカバレッジが要件 (>80%) を満たしている
- [ ] コードがプロジェクトのコードスタイルガイドラインに従っている (`code_styleguides/` で定義)
- [ ] すべての公開関数/メソッドが文書化されている (例: docstrings, JSDoc, GoDoc)
- [ ] 型安全性が強制されている (例: type hints, TypeScript types, Go types)
- [ ] リントまたは静的解析エラーがない (プロジェクトの設定済みツールを使用)
- [ ] モバイルで正しく動作する (該当する場合)
- [ ] 必要に応じてドキュメントが更新されている
- [ ] セキュリティ脆弱性が導入されていない

## 開発コマンド

**AIエージェントへの指示: このセクションは、プロジェクト固有の言語、フレームワーク、ビルドツールに合わせて調整されるべきである。**

### セットアップ

```bash
# 例: 開発環境をセットアップするコマンド（例: 依存関係のインストール、データベースの設定）
# 例: Node.jsプロジェクトの場合: npm install
# 例: Goプロジェクトの場合: go mod tidy
```

### 日々の開発

```bash
# 例: 一般的な日々のタスクのコマンド（例: 開発サーバーの起動、テストの実行、リント、フォーマット）
# 例: Node.jsプロジェクトの場合: npm run dev, npm test, npm run lint
# 例: Goプロジェクトの場合: go run main.go, go test ./..., go fmt ./...
```

### コミット前

```bash
# 例: すべてのプレコミットチェックを実行するコマンド（例: フォーマット、リント、型チェック、テスト実行）
# 例: Node.jsプロジェクトの場合: npm run check
# 例: Goプロジェクトの場合: make check (Makefileが存在する場合)
```

## テスト要件

### 単体テスト

- すべてのモジュールに対応するテストが必要である。
- 適切なテストセットアップ/ティアダウンメカニズムを使用する (例: fixtures, beforeEach/afterEach)。
- 外部依存関係をモックする。
- 成功ケースと失敗ケースの両方をテストする。

### 統合テスト

- 完全なユーザーフローをテストする
- データベーストランザクションを検証する
- 認証と認可をテストする
- フォーム送信を確認する

### モバイルテスト

- 可能な限り実際の iPhone でテストする
- Safari 開発者ツールを使用する
- タッチインタラクションをテストする
- レスポンシブレイアウトを検証する
- 3G/4G でのパフォーマンスを確認する

## コードレビュープロセス

### セルフレビューチェックリスト

レビューを依頼する前に:

1. **機能性**
   - 機能が仕様通りに動作する
   - エッジケースが処理されている
   - エラーメッセージがユーザーフレンドリーである

2. **コード品質**
   - スタイルガイドに従っている
   - DRY原則が適用されている
   - 変数/関数名が明確である
   - 適切なコメントがある

3. **テスト**
   - 単体テストが包括的である
   - 統合テストが合格している
   - カバレッジが十分である (>80%)

4. **セキュリティ**
   - ハードコードされたシークレットがない
   - 入力検証が存在する
   - SQLインジェクションが防止されている
   - XSS保護が行われている

5. **パフォーマンス**
   - データベースクエリが最適化されている
   - 画像が最適化されている
   - 必要に応じてキャッシュが実装されている

6. **モバイル体験**
   - タッチターゲットが十分である (44x44px)
   - ズームなしでテキストが読める
   - モバイルでのパフォーマンスが許容範囲内である
   - インタラクションがネイティブに感じる

## コミットガイドライン

### メッセージ形式

```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

### タイプ

- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメントのみ
- `style`: フォーマット、セミコロンの欠落など
- `refactor`: バグ修正も機能追加もしないコード変更
- `test`: 不足しているテストの追加
- `chore`: メンテナンス作業

### 例

```bash
git commit -m "feat(auth): Add remember me functionality"
git commit -m "fix(posts): Correct excerpt generation for short posts"
git commit -m "test(comments): Add tests for emoji reaction limits"
git commit -m "style(mobile): Improve button touch targets"
```

## 完了の定義 (Definition of Done)

タスクは次の場合に完了とする:

1. すべてのコードが仕様通りに実装されている
2. 単体テストが書かれ、合格している
3. コードカバレッジがプロジェクトの要件を満たしている
4. ドキュメントが完了している (該当する場合)
5. コードがすべての設定済みリントおよび静的解析チェックに合格している
6. モバイルで美しく動作する (該当する場合)
7. 実装メモが `plan.md` に追加されている
8. 適切なメッセージで変更がコミットされている
9. タスクサマリーを含む Git note がコミットに添付されている

## 色別手続き (Emergency Procedures)

### 実稼働環境での重大なバグ

1. main からホットフィックスブランチを作成する
2. バグに対する失敗するテストを書く
3. 最小限の修正を実装する
4. モバイルを含めて徹底的にテストする
5. 直ちにデプロイする
6. plan.md に文書化する

### データ消失

1. すべての書き込み操作を停止する
2. 最新のバックアップから復元する
3. データの整合性を検証する
4. インシデントを文書化する
5. バックアップ手順を更新する

### セキュリティ侵害

1. すべてのシークレットを直ちにローテーションする
2. アクセスログをレビューする
3. 脆弱性にパッチを当てる
4. 影響を受けたユーザーに通知する (もしあれば)
5. セキュリティ手順を文書化し、更新する

## デプロイメントワークフロー

### デプロイ前チェックリスト

- [ ] すべてのテストが合格している
- [ ] カバレッジ >80%
- [ ] リントエラーがない
- [ ] モバイルテスト完了
- [ ] 環境変数が設定されている
- [ ] データベースマイグレーションの準備ができている
- [ ] バックアップが作成されている

### デプロイ手順

1. 機能ブランチを main にマージする
2. バージョンでリリースにタグを付ける
3. デプロイメントサービスにプッシュする
4. データベースマイグレーションを実行する
5. デプロイメントを検証する
6. クリティカルパスをテストする
7. エラーを監視する

### デプロイ後

1. アナリティクスを監視する
2. エラーログを確認する
3. ユーザーフィードバックを収集する
4. 次のイテレーションを計画する

## 継続的改善

- 毎週ワークフローを見直す
- 問題点に基づいて更新する
- 学んだ教訓を文書化する
- ユーザーの幸福のために最適化する
- シンプルで保守しやすく保つ
